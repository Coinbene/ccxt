# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
import hashlib
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS


class coinbenespot(Exchange):

    def describe(self):
        return self.deep_extend(super(coinbenespot, self).describe(), {
            'id': 'coinbenespot',
            'name': 'CoinBene',
            'countries': ['CN', 'US'],
            'version': 'v2',
            'rateLimit': 1500,
            'certified': True,
            # new metainfo interface
            'has': {
                'CORS': False,
                'fetchMarkets': True,
                'fetchOrderBook': True,
                'fetchTrades': True,
                'fetchTicker': True,
                'fetchBalance': True,
                'createOrder': True,
                'cancelOrder': True,
                'fetchOrder': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://res.coinbene.mobi/coinbene-article/9f524eb71731f51e.png',
                'api': 'http://openapi-exchange.coinbene.com',
                'www': 'http://www.coinbene.com',
                'prefixPath': '/api/exchange/v2/',
                'referral': 'http://www.coinbene.com',
                'doc': [
                    'https://github.com/Coinbene/API-SPOT-v2-Documents',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'market/tradePair/list',
                        'market/tradePair/one',
                        'market/ticker/list',
                        'market/ticker/one',
                        'market/orderBook',
                        'market/trades',
                        'market/instruments/candles',
                        'market/rate/list',
                    ],
                },
                'private': {
                    'get': [
                        'account/list',
                        'account/one',
                        'order/info',
                        'order/openOrders',
                        'order/closedOrders',
                        'order/trade/fills',
                    ],
                    'post': [
                        'order/place',
                        'order/cancel',
                        'order/batchCancel',
                        'order/batchPlaceOrder',
                    ],
                },
            },
            'fees': None,
            'commonCurrencies': None,
            'exceptions': None,
            'precisionMode': None,
            'options': {
                'currencyNames': None,
                'orderTypes': {
                    'limit': '1',
                    'market': '2',
                },
                'direction': {
                    'buy': '1',
                    'sell': '2',
                },
            },
        })

    def fetch_market_list(self):
        response = self.public_get_market_tradepair_list()
        result = []
        for i in range(0, len(response['data'])):
            market = response['data'][i]
            id = self.safe_string(market, 'symbol')
            id = id.upper()
            base = None
            quote = None
            baseId = None
            quoteId = None
            if id.find('/') >= 0:
                parts = id.split('/')
                base = parts[0]
                baseId = base.lower()
                quote = parts[1]
                quoteId = quote.lower()
            symbol = base + '/' + quote
            id = baseId + quoteId
            precision = {
                'price': market['pricePrecision'],
                'amount': market['amountPrecision'],
            }
            priceFluctuation = self.safe_float(market, 'priceFluctuation')
            limits = {
                'amount': {
                    'min': self.safe_float(market, 'minAmount'),
                    'max': None,
                },
                'price': {
                    'min': 1 - priceFluctuation,
                    'max': 1 + priceFluctuation,
                },
            }
            limits['cost'] = {
                'min': limits['amount']['min'] * limits['price']['min'],
                'max': None,
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': True,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    def fetch_market(self, symbol, params={}):
        request = {
            'symbol': symbol,
        }
        response = self.public_get_market_tradepair_one(self.extend(request, params))
        market = response['data']
        result = []
        id = self.safe_string(market, 'symbol')
        if id is None:
            return result
        id = id.upper()
        base = None
        quote = None
        baseId = None
        quoteId = None
        if id.find('/') >= 0:
            parts = id.split('/')
            base = parts[0]
            quote = parts[1]
            baseId = base.lower()
            quoteId = quote.lower()
        symbol = base + '/' + quote
        id = baseId + quoteId
        precision = {
            'price': market['pricePrecision'],
            'amount': market['amountPrecision'],
        }
        priceFluctuation = self.safe_float(market, 'priceFluctuation')
        limits = {
            'amount': {
                'min': self.safe_float(market, 'minAmount'),
                'max': None,
            },
            'price': {
                'min': 1 - priceFluctuation,
                'max': 1 + priceFluctuation,
            },
        }
        limits['cost'] = {
            'min': limits['amount']['min'] * limits['price']['min'],
            'max': None,
        }
        result.append({
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'active': True,
            'precision': precision,
            'limits': limits,
            'info': market,
        })
        return result

    def fetch_order_book(self, symbol, depth, params={}):
        request = {
            'symbol': symbol,
            'depth': depth,
        }
        response = self.public_get_market_orderbook(self.extend(request, params))
        code = response['code']
        message = response['message']
        if code != 200:
            raise ExchangeError(self.id + ' message = ' + message)
        orderbook = response['data']
        return orderbook

    def fetch_ticker_list(self, params={}):
        result = []
        response = self.public_get_market_ticker_list(params)
        for i in range(0, len(response['data'])):
            ticker = response['data'][i]

            symbol = ticker['symbol']
            last = ticker['latestPrice']
            bid = ticker['bestBid']
            ask = ticker['bestAsk']
            high24 = ticker['high24h']
            low24 = ticker['low24h']
            volume24h = ticker['volume24h']

            result.append({
                'symbol': symbol,
                'info': ticker,
                'timestamp': None,
                'datetime': None,
                'high': None,
                'low': None,
                'bid': bid,
                'bidVolume': None,
                'ask': ask,
                'askVolumen': None,
                'vwap': None,
                'open': None,
                'close': None,
                'last': last,
                'previousClose': None,
                'change': None,
                'precentage': None,
                'average': None,
                'baseVolume': None,
                'quoteVolume': None,
            })
        return result

    def fetch_ticker(self, symbol, params={}):
        result = []
        request = {
            'symbol': symbol,
        }
        response = self.public_get_market_ticker_one(self.extend(request, params))
        ticker = response['data']
        id = ticker['symbol']
        if id is None:
            return result

        last = ticker['latestPrice']
        bid = ticker['bestBid']
        ask = ticker['bestAsk']
        high24 = ticker['high24h']
        low24 = ticker['low24h']
        volume24h = ticker['volume24h']

        result.append({
            'symbol': id,
            'info': ticker,
            'timestamp': None,
            'datetime': None,
            'high': None,
            'low': None,
            'bid': bid,
            'bidVolume': None,
            'ask': ask,
            'askVolumen': None,
            'vwap': None,
            'open': None,
            'close': None,
            'last': last,
            'previousClose': None,
            'change': None,
            'precentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': None,
        })

        return result

    def fetch_trade_list(self, symbol, params={}):
        result = []
        request = {
            'symbol': symbol,
        }
        response = self.public_get_market_trades(self.extend(request, params))
        for i in range(0, len(response['data'])):
            trade = response['data'][i]
            # [symbol|price|volume|direction|tradeTime]

            symbol = trade[0]
            price = trade[1]
            volume = trade[2]
            direction = trade[3]
            time = trade[4]

            result.append({
                'id': None,
                'info': trade,
                'timestamp': None,
                'datetime': time,
                'symbol': symbol,
                'order': None,
                'type': None,
                'side': direction,
                'price': price,
                'amount': volume,
            })

        return result

    def fetch_candles(self, symbol, period, start, end, params={}):
        request = {
            'symbol': symbol,
            'period': period,
        }

        if start is not None:
            request['start'] = start
        if end is not None:
            request['end'] = end

        response = self.public_get_market_instruments_candles(self.extend(request, params))
        candles = response['data']
        return candles

    def fetch_rate_list(self):
        response = self.public_get_market_rate_list()
        ratelist = response['data']
        return ratelist

    def fetch_balance_list(self, params={}):
        response = self.private_get_account_list()
        code = response['code']
        if code != 200:
            return response
        result = {}
        for i in range(0, len(response['data'])):
            balance = response['data'][i]

            asset = self.safe_string(balance, 'asset')
            available = self.safe_string(balance, 'available')
            frozenBalance = self.safe_string(balance, 'frozenBalance')
            totalBalance = self.safe_string(balance, 'totalBalance')

            temp = {}
            temp['free'] = available
            temp['used'] = frozenBalance
            temp['total'] = totalBalance

            result[asset] = temp

        return result

    def fetch_balance(self, asset, params={}):
        request = {
            'asset': asset,
        }
        response = self.private_get_account_one(self.extend(request, params))
        code = response['code']
        if code != 200:
            return response
        result = {}

        balance = response['data']
        asset = self.safe_string(balance, 'asset')
        available = self.safe_string(balance, 'available')
        frozenBalance = self.safe_string(balance, 'frozenBalance')
        totalBalance = self.safe_string(balance, 'totalBalance')

        temp = {}
        temp['free'] = available
        temp['used'] = frozenBalance
        temp['total'] = totalBalance

        result[asset] = temp
        return result

    def create_order(self, symbol, side, price, quantity, type, notional=None, params={}):
        result = {}
        request = {
            'symbol': symbol,
            'direction': side,
            'price': price,
            'quantity': quantity,
            'orderType': type,
            'notional': notional,
        }
        response = self.private_post_order_place(self.extend(request, params))
        code = response['code']
        if code != 200:
            return response

        result['id'] = response['data']['orderId']
        result['info'] = response['data']

        return result

    def fetch_order(self, orderId, symbol=None, params={}):
        request = {
            'orderId': orderId,
        }
        response = self.private_get_order_info(self.extend(request, params))
        return self.parse_order(response['data'])

    def cancel_order(self, orderId, params={}):
        request = {
            'orderId': orderId,
        }

        response = self.private_post_order_cancel(self.extend(request, params))
        code = response['code']
        if code != 200:
            return response
        return {
            'orderId' : orderId,
            'result': True,
        }

    def cancel_all_orders(self, symbol=None, params={}):
        return self.private_post_order_batchCancel(params)

    def parse_order(self, order):
        orderId = self.safe_string(order, 'orderId')
        base = self.safe_string(order, 'baseAsset')
        quote = self.safe_string(order, 'quoteAsset')
        symbol = base + "/" + quote
        direction = self.safe_string(order, 'orderDirection')
        quantity = self.safe_string(order, 'quantity')
        amount = self.safe_string(order, 'amount')
        filledAmount = self.safe_string(order, 'filledAmount')
        takerFee = self.safe_string(order, 'takerFeeRate')
        makerFee = self.safe_string(order, 'makerFeeRate')
        avgPrice = self.safe_string(order, 'avgPrice')
        orderPrice = self.safe_string(order, 'orderPrice')
        orderStatus = self.safe_string(order, 'orderStatus')
        orderTime = self.safe_string(order, 'orderTime')
        totalFee = self.safe_string(order, 'totalFee')
        timestamp = self.milliseconds()

        return {
            'info': order,
            'id': orderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': None,
            'side': direction,
            'price': orderPrice,
            'average': avgPrice,
            'amount': amount,
            'remaining': None,
            'filled': filledAmount,
            'status': orderStatus,
            'fee': None,
        }

    def fetch_open_orders(self, symbol=None, latestOrderId=None, limit=None, params={}):
        result = []
        request = {}
        if limit is not None:
            request['limit'] = limit
        if symbol is not None:
            request['symbol'] = symbol
        if latestOrderId is not None:
            request['latestOrderId'] = latestOrderId

        response = self.private_get_order_openorders(self.extend(request, params))
        orders = response['data']
        if orders is None:
            return result

        for i in range(0, len(orders)):
            order = orders[i]
            result.append({
                'id': order['orderId'],
                'datetime': order['orderTime'],
                'timestamp': None,
                'lastTradeTimestamp': None,
                'status': order['orderStatus'],
                'symbol': order['symbol'],
                'type': None,
                'side': order['orderDirection'],
                'price': order['orderPrice'],
                'amount': order['amount'],
                'filled': order['filledAmount'],
                'remaining': None,
                'cost': None,
                'fee': order['fee'],
                'info': order,
            })

        return result

    def fetch_closed_orders(self, symbol=None, latestOrderId=None, limit=None, params={}):
        result = []
        request = {}
        if limit is not None:
            request['limit'] = limit
        if symbol is not None:
            request['symbol'] = symbol
        if latestOrderId is not None:
            request['latestOrderId'] = latestOrderId

        response = self.private_get_order_closedorders(self.extend(request, params))
        orders = response['data']
        if orders is None:
            return result

        for i in range(0, len(orders)):
            order = orders[i]
            result.append({
                'id': order['orderId'],
                'datetime': order['orderTime'],
                'timestamp': None,
                'lastTradeTimestamp': None,
                'status': order['orderStatus'],
                'symbol': order['symbol'],
                'type': None,
                'side': order['orderDirection'],
                'price': order['orderPrice'],
                'amount': order['amount'],
                'filled': order['filledAmount'],
                'remaining': None,
                'cost': None,
                'fee': order['fee'],
                'info': order,
            })

        return result

    def fetch_order_fills(self, orderId, params={}):
        result = []
        request = {}
        if orderId is not None:
            request['orderId'] = orderId

        response = self.private_get_order_trade_fills(self.extend(request, params))
        code = response['code']
        if code != 200:
            return response

        fills = response['data']
        if fills is None:
            return result

        for i in range(0, len(fills)):
            fill = fills[i]
            price = fill['price']
            quantity = fill['quantity']
            amount = fill['amount']
            fee = fill['fee']
            direction = fill['direction']
            tradeTime = fill['tradeTime']
            feeByConi = fill['feeByConi']

            result.append({
                'info': fill,
                'id': None,
                'timestamp': None,
                'datetime': tradeTime,
                'symbol': None,
                'order': orderId,
                'type': None,
                'price': price,
                'amount': amount,
            })


        return result

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        path = self.urls['prefixPath'] + path
        isArray = isinstance(params, list)
        # request = '/api/' + api + '/' + self.version + '/'
        request = path if isArray else self.implode_params(path, params)
        query = params if isArray else self.omit(params, self.extract_params(path))
        url = self.urls['api'] + request
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        if api == 'private':
            self.check_required_credentials()
            timestamp = self.iso8601(self.milliseconds())
            headers = {
                'ACCESS-KEY': self.apiKey,
                'ACCESS-TIMESTAMP': timestamp,
            }
            auth = timestamp + method + request
            if method == 'GET':
                if query:
                    urlencodedQuery = '?' + self.urlencode(query)
                    url += urlencodedQuery
                    auth += urlencodedQuery
            else:
                if isArray or query:
                    body = self.json(query)
                    auth += body
                headers['Content-Type'] = 'application/json'
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'hex')
            headers['ACCESS-SIGN'] = signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        if code >= 400:
            if body[0] == '{':
                feedback = self.id + ' ' + body
                message = self.safe_string_2(response, 'message', 'error')
                self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
                self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
                raise ExchangeError(feedback)  # unknown message
